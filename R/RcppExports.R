# Generated by using Rcpp::compileAttributes() -> do not edit by hand
# Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

#' @importFrom RcppParallel RcppParallelLibs
NULL

#' GDFMM sampler
GDFMM_sampler_c <- function(dat, n_iter, burn_in, thin, seed, P0_prior_name, FixPart, option) {
    .Call(`_GDFMM_GDFMM_sampler_c`, dat, n_iter, burn_in, thin, seed, P0_prior_name, FixPart, option)
}

#' GDFMM sampler
GDFMM_marginal_sampler_c <- function(dat, n_iter, burn_in, thin, seed, P0_prior_name, FixPart, option) {
    .Call(`_GDFMM_GDFMM_marginal_sampler_c`, dat, n_iter, burn_in, thin, seed, P0_prior_name, FixPart, option)
}

#' MCMC_conditional_c
MCMC_conditional_c <- function(data_list, n_iter, burn_in, thin, seed, P0_prior_name, FixPart, algorithm, option) {
    .Call(`_GDFMM_MCMC_conditional_c`, data_list, n_iter, burn_in, thin, seed, P0_prior_name, FixPart, algorithm, option)
}

#' Rigon - lastirling
#'
#' Vector of Stirling numbers s(n,1)...s(n,n)
#' @export
lastirling1 <- function(n) {
    .Call(`_GDFMM_lastirling1`, n)
}

#' Rigon - lastirlings1
#'
#' Commento Ale, questa è l'estensione di lastirling1. Questa ritorna una matrice triangolare inferiori, l'argomento n
#' vuol dire che deve calcolare tutti gli sviluppi fino ad n, partendo da s(1) che è banalmente uguale ad uno. Anche
#' questa lavora in scala logaritmica.
#' @export
lastirlings1 <- function(n) {
    .Call(`_GDFMM_lastirlings1`, n)
}

#' Raising Factorial
#'
#' \loadmathjax This function computes the rising factorial \mjseqn{(a)^{n}} using the gsl code for the Pochhammer symbol, i.e
#' \mjsdeqn{(a)^{n} = \frac{\Gamma(a+n)}{\Gamma(a)}}.
#' The raising (here denote with the upper apex) and the falling factorial (here denote with the lower apex) are related by the following relationship
#' \mjsdeqn{(a)_{n} = (-1)^{n}(a)^{n}}.
NULL

#' log Raising Factorial
#'
#' \loadmathjax This function computes the logarithm of the rising factorial \mjseqn{(a)^{n}} using the gsl code for the log of Pochhammer symbol.
#' See \code{\link{raising_factorial}} and \code{\link{compute_Pochhammer}} for details.
NULL

#' Raising Factorial
#'
#' \loadmathjax This function computes the rising factorial \mjseqn{(a)^{n}} using the gsl code for the Pochhammer symbol, i.e
#' \mjsdeqn{(a)^{n} = \frac{\Gamma(a+n)}{\Gamma(a)}}.
#' The raising (here denote with the upper apex) and the falling factorial (here denote with the lower apex) are related by the following relationship
#' \mjsdeqn{(a)_{n} = (-1)^{n}(a)^{n}}.
NULL

#' log Raising Factorial
#'
#' \loadmathjax This function computes the logarithm of the rising factorial \mjseqn{(a)^{n}} using the gsl code for the log of Pochhammer symbol.
#' See \code{\link{raising_factorial}} and \code{\link{compute_Pochhammer}} for details.
NULL

#' Falling Factorial
#'
#' \loadmathjax This function computes the falling factorial \mjseqn{ a_{n} }. See \code{\link{raising_factorial}} for details.
#' The raising (here denote with the upper apex) and the falling factorial (here denote with the lower apex) are related by the following relationship
#' \mjsdeqn{(a)_{n} = (-1)^{n}(a)^{n}}.
NULL

#' log Falling Factorial
#'
#' \loadmathjax This function computes the logarithm of the falling factorial \mjseqn{ a_{n} } using the gsl code for the log of Pochhammer symbol.
#' See \code{\link{my_falling_factorial}} and \code{\link{compute_Pochhammer}} for details.
NULL

#' Falling Factorial
#'
#' \loadmathjax This function computes the falling factorial \mjseqn{ a_{n} }. See \code{\link{raising_factorial}} for details.
#' The raising (here denote with the upper apex) and the falling factorial (here denote with the lower apex) are related by the following relationship
#' \mjsdeqn{(a)_{n} = (-1)^{n}(a)^{n}}.
NULL

#' log Falling Factorial
#'
#' \loadmathjax This function computes the logarithm of the falling factorial \mjseqn{ a_{n} } using the gsl code for the log of Pochhammer symbol.
#' See \code{\link{my_falling_factorial}} and \code{\link{compute_Pochhammer}} for details.
NULL

#' Pochhammer Symbol
#'
#' \loadmathjax This function computes the Pochhammer symbol,
#' \mjsdeqn{(a)^{x} = \frac{\Gamma(a+x)}{\Gamma(a)}}.
#' Where \code{x} is a real number. When x is an integer, such a function coincides with the rising factorial defined in \code{\link{raising_factorial}}.
#' The raising (here denote with the upper apex) and the falling factorial (here denote with the lower apex) are related by the following relationship
#' \mjsdeqn{(a)_{n} = (-1)^{n}(a)^{n}}.
NULL

#' Pochhammer log Symbol
#'
#' \loadmathjax This function computes the Pochhammer symbol in log form. See \code{\link{compute_Pochhammer}} for details.
NULL

#' Build matrix of logC numbers
#'
#' This is the recursive function called by \code{\link{my_logC}} that builds the matrix containing all the log(|C(n,k)|) numbers.
#' It gets as input the element (n,k) to build, the scale s and location r (here defined as positive and non-negative numbers) and the
#' matrix res to be build. The matrix is constructed diagonal by diagonal, starting from the bottom.
#' Important remark, note that log(|C(n,0)|) = log(raising factorial (n,r)).
NULL

#' My logC
#'
#' This function is the recursive formula 2.69 in "Combinatorial methods in discrete distributions" book by Charalambides.
#' It returns an (n+1 x n+1) matrix containing all the log(|C(nn,k)|) numbers, for nn = 0,...,n+1 and k = 0,...,nn.
#' scale and location must be negative and non-positive, respectively.
#' As a consequence, it is memory expensive.
NULL

#' Compute log of absolute values of non Central C number
#'
#' \loadmathjax This is the main function in the computation of C numbers. It uses the (2.69) formula in the "Combinatorial methods in discrete distributions" book.
#' It computes \mjseqn{log(|C(n,k; scale, location)|)} for each k=0,...,n.
#' scale and location must be negative and non-positive, respectively.
#' It uses eigen objects, apparetly it is slower than using Rcpp vectors.
NULL

#' My logC2 - central
#'
#' This function is the recursive formula 2.69 in "Combinatorial methods in discrete distributions" book by Charalambides for central numbers.
#' This is the specialization of \code{\link{my_logC2}} for central C numbers.
#' scale must be negative.
NULL

#' compute_logC - Compute log of absolute values of non Central C number
#'
#' \loadmathjax This is the main function in the computation of C numbers. It uses the (2.69) formula in the "Combinatorial methods in discrete distributions" book.
#' It computes \mjseqn{log(|C(n,k; scale, location)|)} for each k=0,...,n.
#' This implementation uses Rcpp vectors.
#' @param scale must be strictly negative.
#' @param locatio must be non positive. Set to 0 for central C numbers.
#' @export
compute_logC <- function(n, scale, location) {
    .Call(`_GDFMM_compute_logC`, n, scale, location)
}

#' 
p_distinct_prior_c <- function(k, n_j, gamma_j, prior, prior_param, M_max) {
    .Call(`_GDFMM_p_distinct_prior_c`, k, n_j, gamma_j, prior, prior_param, M_max)
}

